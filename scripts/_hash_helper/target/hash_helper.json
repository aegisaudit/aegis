{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"6220243824394883675","abi":{"parameters":[{"name":"source_code","type":{"kind":"array","length":64,"type":{"kind":"field"}},"visibility":"private"},{"name":"audit_results","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"auditor_private_key","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use std::hash::pedersen_hash;\r\n\r\nfn main(\r\n    source_code: [Field; 64],\r\n    audit_results: [Field; 32],\r\n    auditor_private_key: Field,\r\n) -> pub (Field, Field, Field) {\r\n    let skill_hash = pedersen_hash(source_code);\r\n    let criteria_hash = pedersen_hash(audit_results);\r\n    let auditor_commitment = pedersen_hash([auditor_private_key]);\r\n    (skill_hash, criteria_hash, auditor_commitment)\r\n}\r\n","path":"/mnt/c/Projects/Aegis/scripts/_hash_helper/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}