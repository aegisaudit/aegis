// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Test, console2} from "forge-std/Test.sol";
import {AegisRegistry} from "../../src/AegisRegistry.sol";
import {IAegisRegistry} from "../../src/interfaces/IAegisRegistry.sol";
import {AegisErrors} from "../../src/libraries/AegisErrors.sol";

// Import the real UltraHonk verifier (auto-generated by bb from the Noir circuit)
import {HonkVerifier} from "../../src/generated/UltraHonkVerifier.sol";

/// @title AegisE2E
/// @notice End-to-end integration test using the real UltraHonk verifier and CLI-generated proof.
/// @dev Proof fixtures are generated by:
///      1. nargo execute (witness generation)
///      2. bb prove --verifier_target evm (proof generation)
///      The proof and public_inputs files are copied to test/fixtures/
contract AegisE2E is Test {
    AegisRegistry public registry;
    HonkVerifier public honkVerifier;

    address public publisher = makeAddr("publisher");

    // These are the public inputs used to generate the proof (Pedersen hashes from Noir circuit).
    // They must match what's in Prover.toml and the proof fixtures.
    bytes32 public skillHash = 0x0eba0c961970330401e4d801bb41e1d85a910c9878d552f5fc7a9d73ee11cb51;
    bytes32 public criteriaHash = 0x1c5562cca0aa50afba89687ee22ea1d25dd7f2dc8f1332cd1567fc9a46d05331;
    bytes32 public auditorCommitment = 0x1a65fb219ffd58992a8c16d3038ef77e4696a8e43e1fb2debdb03b5d9b0ee8a9;
    uint8 public auditLevel = 1;

    function setUp() public {
        // Deploy the REAL UltraHonk verifier (auto-generated Solidity from Noir circuit)
        honkVerifier = new HonkVerifier();

        // Deploy AegisRegistry using the real verifier
        registry = new AegisRegistry(address(honkVerifier));

        // Fund test accounts
        vm.deal(publisher, 10 ether);
    }

    /// @notice Test that the real UltraHonk verifier accepts a valid CLI-generated proof
    function test_realVerifier_acceptsValidProof() public {
        // Load the proof and public inputs from CLI-generated fixtures
        bytes memory proof = vm.readFileBinary("test/fixtures/proof.bin");
        bytes memory publicInputsRaw = vm.readFileBinary("test/fixtures/public_inputs.bin");

        // Parse the 4 public inputs from the raw binary (4 x 32 bytes)
        assertEq(publicInputsRaw.length, 128, "Public inputs should be 4 x 32 bytes");

        bytes32[] memory publicInputs = new bytes32[](4);
        for (uint256 i = 0; i < 4; i++) {
            bytes32 val;
            assembly {
                val := mload(add(publicInputsRaw, add(32, mul(i, 32))))
            }
            publicInputs[i] = val;
        }

        // Verify the parsed public inputs match our expected values
        assertEq(publicInputs[0], skillHash, "skill_hash mismatch");
        assertEq(publicInputs[1], criteriaHash, "criteria_hash mismatch");
        assertEq(publicInputs[2], bytes32(uint256(auditLevel)), "audit_level mismatch");
        assertEq(publicInputs[3], auditorCommitment, "auditor_commitment mismatch");

        console2.log("Proof size:", proof.length, "bytes");
        console2.log("Public inputs count:", publicInputs.length);

        // Call the real verifier directly
        bool valid = honkVerifier.verify(proof, publicInputs);
        assertTrue(valid, "Real UltraHonk verifier should accept the CLI-generated proof");
    }

    /// @notice Full E2E: register auditor, register skill with real proof, verify on-chain
    function test_e2e_registerSkillWithRealProof() public {
        // Load proof fixtures
        bytes memory proof = vm.readFileBinary("test/fixtures/proof.bin");
        bytes memory publicInputsRaw = vm.readFileBinary("test/fixtures/public_inputs.bin");

        bytes32[] memory publicInputs = new bytes32[](4);
        for (uint256 i = 0; i < 4; i++) {
            bytes32 val;
            assembly {
                val := mload(add(publicInputsRaw, add(32, mul(i, 32))))
            }
            publicInputs[i] = val;
        }

        // Step 1: Register auditor with stake
        registry.registerAuditor{value: 0.1 ether}(auditorCommitment);

        // Verify auditor is registered
        (uint256 score, uint256 totalStake, uint256 attestationCount) =
            registry.getAuditorReputation(auditorCommitment);
        assertEq(totalStake, 0.1 ether, "Auditor stake mismatch");
        assertEq(attestationCount, 0, "Should have 0 attestations initially");

        // Step 2: Register skill with real ZK proof
        vm.prank(publisher);
        registry.registerSkill{value: 0.001 ether}(
            skillHash,
            "ipfs://QmTest123",
            proof,
            publicInputs,
            auditorCommitment,
            auditLevel
        );

        // Step 3: Verify the attestation was stored correctly
        IAegisRegistry.Attestation[] memory attestations = registry.getAttestations(skillHash);
        assertEq(attestations.length, 1, "Should have 1 attestation");
        assertEq(attestations[0].skillHash, skillHash, "Stored skill_hash mismatch");
        assertEq(attestations[0].auditCriteriaHash, criteriaHash, "Stored criteria_hash mismatch");
        assertEq(attestations[0].auditorCommitment, auditorCommitment, "Stored auditor_commitment mismatch");
        assertEq(attestations[0].auditLevel, auditLevel, "Stored audit_level mismatch");
        assertEq(attestations[0].stakeAmount, 0.1 ether, "Stored stake amount mismatch");

        // Step 4: Verify auditor reputation was updated
        (score, totalStake, attestationCount) = registry.getAuditorReputation(auditorCommitment);
        assertEq(attestationCount, 1, "Auditor should have 1 attestation");
        assertEq(score, 1, "Reputation score should be 1");

        // Step 5: Verify the metadata URI was stored
        assertEq(registry.metadataURIs(skillHash), "ipfs://QmTest123", "Metadata URI mismatch");

        console2.log("=== E2E Test Passed ===");
        console2.log("Skill registered with real UltraHonk ZK proof");
        console2.log("Proof size:", proof.length, "bytes");
        console2.log("Attestations stored:", attestations.length);
    }

    /// @notice Test that re-verification of stored attestation works via the registry
    function test_e2e_reverifyStoredAttestation() public {
        // Setup: register auditor and skill with real proof
        bytes memory proof = vm.readFileBinary("test/fixtures/proof.bin");
        bytes memory publicInputsRaw = vm.readFileBinary("test/fixtures/public_inputs.bin");

        bytes32[] memory publicInputs = new bytes32[](4);
        for (uint256 i = 0; i < 4; i++) {
            bytes32 val;
            assembly {
                val := mload(add(publicInputsRaw, add(32, mul(i, 32))))
            }
            publicInputs[i] = val;
        }

        registry.registerAuditor{value: 0.1 ether}(auditorCommitment);

        vm.prank(publisher);
        registry.registerSkill{value: 0.001 ether}(
            skillHash, "ipfs://QmTest123", proof, publicInputs, auditorCommitment, auditLevel
        );

        // Re-verify the stored attestation through the registry
        bool valid = registry.verifyAttestation(skillHash, 0);
        assertTrue(valid, "Stored attestation should re-verify successfully");
    }

    /// @notice Test that a tampered proof is rejected
    function test_e2e_tamperedProofRejected() public {
        // Load the real proof
        bytes memory proof = vm.readFileBinary("test/fixtures/proof.bin");

        // Tamper with the proof (flip a byte)
        proof[100] = bytes1(uint8(proof[100]) ^ 0xff);

        bytes32[] memory publicInputs = new bytes32[](4);
        publicInputs[0] = skillHash;
        publicInputs[1] = criteriaHash;
        publicInputs[2] = bytes32(uint256(auditLevel));
        publicInputs[3] = auditorCommitment;

        // Register auditor
        registry.registerAuditor{value: 0.1 ether}(auditorCommitment);

        // The tampered proof should cause a revert (verifier returns false or reverts)
        vm.prank(publisher);
        vm.expectRevert();
        registry.registerSkill{value: 0.001 ether}(
            skillHash, "ipfs://QmTest123", proof, publicInputs, auditorCommitment, auditLevel
        );
    }

    /// @notice Test that wrong public inputs are rejected
    function test_e2e_wrongPublicInputsRejected() public {
        // Load the real proof
        bytes memory proof = vm.readFileBinary("test/fixtures/proof.bin");

        // Use wrong public inputs (correct proof but wrong inputs = should fail)
        bytes32[] memory wrongInputs = new bytes32[](4);
        wrongInputs[0] = bytes32(uint256(1)); // wrong skill_hash
        wrongInputs[1] = criteriaHash;
        wrongInputs[2] = bytes32(uint256(auditLevel));
        wrongInputs[3] = auditorCommitment;

        // Register auditor
        registry.registerAuditor{value: 0.1 ether}(auditorCommitment);

        // Wrong inputs should cause a revert
        vm.prank(publisher);
        vm.expectRevert();
        registry.registerSkill{value: 0.001 ether}(
            wrongInputs[0], "ipfs://QmTest123", proof, wrongInputs, auditorCommitment, auditLevel
        );
    }
}
